# Solidity中的Keccak256 

您可以使用Keccak256哈希来验证有效数据负载。 例如，考虑一个生成唯一散列的对象。 这个散列可以保存在区块链上，同时保存的信息包括谁保存了它、保存的时间等等。 之后，当有人看到来自其他来源的对象时，他们可以自己计算哈希值，然后向区块链查询真实性。 区块链要么响应不存在具有该散列的已知对象(不真实)，要么能够使用记录的详细信息响应。 这只是哈希的众多用例之一。  

 

请记住，您可以从一个输入创建一个惟一的散列，但不能从该散列确定输入。 这是一条单行道，提供了独特的真实性。  

 

kecak是一系列加密哈希函数，最终被标准化为SHA-3。 以太坊将其称为kecak而不是SHA-3，因为它的参数与当前的SHA-3略有不同。 Keccak256是一个加密函数。 该函数接收任意数量的输入，并将其转换为唯一的32字节散列。 



下面的示例合约获取一个文本值、一个数字和一个以太坊地址，并使用Keccak256将其转换为唯一的32字节散列。 这是一个关于如何将值散列到唯一id的简单演示。  

 

试用下面的示例合约。 在函数中输入文本、数字和以太坊地址，并注意bytes32输出(散列)。 然后更改其中一个参数，重新生成bytes32输出，您将注意到散列发生了变化。 最后，将所有参数更改为开始时的值，bytes32输出(散列)将与原始散列相同。 



```solidity
pragma solidity ^0.8.0;

contract hashtest {
    function hash(string memory _text, uint _num, address _addr) public pure returns (bytes32) {
        return keccak256(abi.encode(_text, _num, _addr));
    }
}
```

